class Order < ActiveRecord::Base

	belongs_to :user
<<<<<<< HEAD
	has_many :products

	validates_presence_of :user, :products, :address
=======
	has_many :order_products
	# has_many :products, through: :order_products 

	def products
		self.order_products #.collect(&:product)
	end

	def products= prods
		self.order_products.delete_all

		prods = [prods] unless prods.kind_of?(Array)
		prods.each do |prod|
			op = self.order_products.new
			op.product = prod
		end
	end

	# def products<< prods
	# 	prods.each do |prod|
	# 		op = self.order_products.new
	# 		op.product = prod
	# 	end	
	# end

	validates_presence_of :user, :address, :order_products

	# validates_presence_of :user, :products,:address
>>>>>>> FETCH_HEAD

	scope :all_by_status, lambda{|status| where(status: status).all}

	alias_attribute :date_of_purchase, :created_at
	alias_attribute :time_of_status_change, :status_change_date

	def total_price
		self.products.reduce(0){|sum, product| sum+= product.price}
	end

	def total_discount
		price_without_discount = self.products.reduce(0){|sum, product| sum+= product.base_price}
		100*total_price/price_without_discount
	end

	def transfer_products
<<<<<<< HEAD
		self.user.products.all.each do |product|
			self.products << product
=======
		self.user.products.all.uniq.each do |product|
			self.order_products << OrderProduct.convert(product, product.quantity_for(self.user))
>>>>>>> FETCH_HEAD
			self.user.remove_product product
			product.retire
		end
	end

	STATUSES = {
		:cancel => 'cancelled',
		:pay => 'paid', 
		:is_sent => 'shipped', 
		:is_returned => 'returned'
	}

	STATUSES.each do |method_name, stat|
		define_method method_name do
			self.status = stat
			update_status_date
		end
	end

	private
	
<<<<<<< HEAD
		def status= stat
			super
		end

		def update_status_date
			self.status_change_date = Time.now
		end
=======
	def status= stat
		super
	end

	def update_status_date
		self.status_change_date = Time.now
	end
>>>>>>> FETCH_HEAD

end
